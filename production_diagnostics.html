<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Production Socket.IO Diagnostics</title>
    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        max-width: 1200px;
        margin: 0 auto;
        padding: 20px;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: #333;
        min-height: 100vh;
      }
      .container {
        background: white;
        padding: 30px;
        border-radius: 12px;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
      }
      .header {
        text-align: center;
        margin-bottom: 30px;
        color: #2c3e50;
      }
      .status {
        padding: 12px;
        border-radius: 6px;
        margin: 10px 0;
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .success {
        background: #d1f2eb;
        color: #00695c;
        border-left: 4px solid #00897b;
      }
      .error {
        background: #ffebee;
        color: #c62828;
        border-left: 4px solid #d32f2f;
      }
      .warning {
        background: #fff8e1;
        color: #f57600;
        border-left: 4px solid #ff9800;
      }
      .info {
        background: #e3f2fd;
        color: #1565c0;
        border-left: 4px solid #2196f3;
      }

      .test-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
        gap: 20px;
        margin: 20px 0;
      }

      .test-card {
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        padding: 20px;
        background: #fafafa;
      }

      .test-card h3 {
        margin-top: 0;
        color: #2c3e50;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 12px 24px;
        border-radius: 6px;
        cursor: pointer;
        font-weight: 500;
        margin: 5px;
        transition: all 0.3s ease;
      }
      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }
      button:disabled {
        background: #bdbdbd;
        cursor: not-allowed;
        transform: none;
      }

      .primary-btn {
        background: linear-gradient(135deg, #4caf50 0%, #45a049 100%);
        font-size: 16px;
        padding: 15px 30px;
      }

      input,
      select {
        padding: 12px;
        border: 1px solid #ddd;
        border-radius: 6px;
        font-size: 14px;
        width: 300px;
        margin: 5px;
      }

      .log-container {
        margin-top: 30px;
      }

      .log {
        background: #1e1e1e;
        color: #00ff00;
        padding: 20px;
        border-radius: 8px;
        height: 400px;
        overflow-y: auto;
        font-family: 'Courier New', monospace;
        font-size: 13px;
        white-space: pre-wrap;
        line-height: 1.4;
      }

      .config-info {
        background: #f5f5f5;
        padding: 15px;
        border-radius: 6px;
        margin: 15px 0;
        font-family: monospace;
        font-size: 13px;
      }

      .progress-bar {
        width: 100%;
        height: 4px;
        background: #e0e0e0;
        border-radius: 2px;
        overflow: hidden;
        margin: 10px 0;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #4caf50, #8bc34a);
        width: 0%;
        transition: width 0.3s ease;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="header">
        <h1>üîß Production Socket.IO Diagnostics</h1>
        <p>Comprehensive testing tool for Socket.IO connection issues in production</p>
      </div>

      <div class="config-info">
        <strong>Test Configuration:</strong><br />
        Server: <span id="serverInfo">http://103.147.163.46:5090</span><br />
        Environment: <span id="envInfo">Production</span><br />
        Timestamp: <span id="timestamp"></span>
      </div>

      <div style="text-align: center; margin: 20px 0">
        <button class="primary-btn" onclick="runFullDiagnostics()">üöÄ Run Full Diagnostics</button>
        <button onclick="clearLog()">üóëÔ∏è Clear Log</button>
        <button onclick="exportResults()">üìã Export Results</button>
      </div>

      <div class="progress-bar">
        <div class="progress-fill" id="progressBar"></div>
      </div>

      <div class="test-grid">
        <div class="test-card">
          <h3>üåê Network Tests</h3>
          <button onclick="testBasicHTTP()">HTTP Connectivity</button>
          <button onclick="testSocketIOEndpoint()">Socket.IO Endpoint</button>
          <button onclick="testCORS()">CORS Configuration</button>
          <button onclick="testDNS()">DNS Resolution</button>
        </div>

        <div class="test-card">
          <h3>üîå Socket.IO Tests</h3>
          <button onclick="testPollingOnly()">Polling Transport</button>
          <button onclick="testWebSocketOnly()">WebSocket Transport</button>
          <button onclick="testConnectionUpgrade()">Connection Upgrade</button>
          <button onclick="testReconnection()">Reconnection Logic</button>
        </div>

        <div class="test-card">
          <h3>‚ö° Performance Tests</h3>
          <button onclick="testLatency()">Connection Latency</button>
          <button onclick="testThroughput()">Message Throughput</button>
          <button onclick="testStability()">Connection Stability</button>
          <button onclick="testLoadHandling()">Load Handling</button>
        </div>

        <div class="test-card">
          <h3>üõ†Ô∏è Production Checks</h3>
          <button onclick="testProxyConfig()">Proxy Configuration</button>
          <button onclick="testSSLHandling()">SSL/TLS Handling</button>
          <button onclick="testFirewallRules()">Firewall Rules</button>
          <button onclick="testResourceLimits()">Resource Limits</button>
        </div>
      </div>

      <div class="log-container">
        <h3>üìä Diagnostic Results</h3>
        <div id="log" class="log">
          Production Socket.IO Diagnostic Tool v2.0 Ready to analyze your Socket.IO connection... Click "Run Full
          Diagnostics" to start comprehensive testing. ===============================================
        </div>
      </div>
    </div>

    <script>
      const SERVER_URL = 'http://103.147.163.46:5090';
      const log = document.getElementById('log');
      let testResults = {};
      let socket = null;
      let currentTestProgress = 0;
      const totalTests = 16;

      // Initialize
      document.getElementById('serverInfo').textContent = SERVER_URL;
      document.getElementById('timestamp').textContent = new Date().toLocaleString();

      function addLog(message, type = 'info') {
        const timestamp = new Date().toLocaleTimeString();
        const colors = {
          success: '#00ff00',
          error: '#ff4444',
          warning: '#ffaa00',
          info: '#00aaff',
        };

        const icon = type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
        log.innerHTML += `<span style="color: ${colors[type] || '#00ff00'}">[[${timestamp}]] ${icon} ${message}</span>\n`;
        log.scrollTop = log.scrollHeight;
      }

      function updateProgress() {
        currentTestProgress++;
        const percentage = (currentTestProgress / totalTests) * 100;
        document.getElementById('progressBar').style.width = percentage + '%';
      }

      function clearLog() {
        log.innerHTML = 'Log cleared - Ready for new diagnostics...\n';
        currentTestProgress = 0;
        document.getElementById('progressBar').style.width = '0%';
        testResults = {};
      }

      async function makeRequest(url, options = {}) {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), options.timeout || 10000);

        try {
          const response = await fetch(url, {
            ...options,
            signal: controller.signal,
          });
          clearTimeout(timeoutId);
          return response;
        } catch (error) {
          clearTimeout(timeoutId);
          throw error;
        }
      }

      async function testBasicHTTP() {
        addLog('Testing basic HTTP connectivity...', 'info');
        try {
          const start = Date.now();
          const response = await makeRequest(`${SERVER_URL}/health`);
          const duration = Date.now() - start;

          if (response.ok) {
            const data = await response.json();
            addLog(`HTTP connectivity OK (${duration}ms): ${JSON.stringify(data)}`, 'success');
            testResults.http = { status: 'pass', duration, data };
          } else {
            addLog(`HTTP error: ${response.status} ${response.statusText}`, 'error');
            testResults.http = { status: 'fail', error: `${response.status} ${response.statusText}` };
          }
        } catch (error) {
          addLog(`HTTP connectivity failed: ${error.message}`, 'error');
          testResults.http = { status: 'fail', error: error.message };
        }
        updateProgress();
      }

      async function testSocketIOEndpoint() {
        addLog('Testing Socket.IO endpoint...', 'info');
        try {
          const start = Date.now();
          const response = await makeRequest(`${SERVER_URL}/socket.io/?EIO=4&transport=polling`);
          const duration = Date.now() - start;

          if (response.ok) {
            const text = await response.text();
            if (text.includes('sid')) {
              addLog(`Socket.IO endpoint OK (${duration}ms)`, 'success');
              addLog(`Response: ${text.substring(0, 100)}...`, 'info');
              testResults.socketEndpoint = { status: 'pass', duration, response: text };
            } else {
              addLog(`Unexpected Socket.IO response: ${text}`, 'warning');
              testResults.socketEndpoint = { status: 'warning', response: text };
            }
          } else {
            addLog(`Socket.IO endpoint error: ${response.status}`, 'error');
            testResults.socketEndpoint = { status: 'fail', error: response.status };
          }
        } catch (error) {
          addLog(`Socket.IO endpoint failed: ${error.message}`, 'error');
          testResults.socketEndpoint = { status: 'fail', error: error.message };
        }
        updateProgress();
      }

      async function testCORS() {
        addLog('Testing CORS configuration...', 'info');
        try {
          const response = await makeRequest(`${SERVER_URL}/health`, {
            method: 'GET',
            headers: { Origin: 'http://test-origin.com' },
          });

          const corsHeaders = {
            origin: response.headers.get('Access-Control-Allow-Origin'),
            methods: response.headers.get('Access-Control-Allow-Methods'),
            headers: response.headers.get('Access-Control-Allow-Headers'),
            credentials: response.headers.get('Access-Control-Allow-Credentials'),
          };

          addLog(`CORS headers: ${JSON.stringify(corsHeaders, null, 2)}`, 'success');
          testResults.cors = { status: 'pass', headers: corsHeaders };
        } catch (error) {
          addLog(`CORS test failed: ${error.message}`, 'error');
          testResults.cors = { status: 'fail', error: error.message };
        }
        updateProgress();
      }

      async function testDNS() {
        addLog('Testing DNS resolution...', 'info');
        try {
          const start = Date.now();
          // This is a basic test - just see if we can resolve the domain
          await makeRequest(`${SERVER_URL}/health`, { timeout: 5000 });
          const duration = Date.now() - start;
          addLog(`DNS resolution OK (${duration}ms)`, 'success');
          testResults.dns = { status: 'pass', duration };
        } catch (error) {
          addLog(`DNS resolution may have issues: ${error.message}`, 'warning');
          testResults.dns = { status: 'warning', error: error.message };
        }
        updateProgress();
      }

      async function loadSocketIOClient() {
        if (typeof io !== 'undefined') return true;

        return new Promise((resolve, reject) => {
          addLog('Loading Socket.IO client library...', 'info');
          const script = document.createElement('script');
          script.src = 'https://cdn.socket.io/4.7.2/socket.io.min.js';
          script.onload = () => {
            addLog('Socket.IO client loaded from CDN', 'success');
            resolve(true);
          };
          script.onerror = () => {
            addLog('Failed to load Socket.IO client', 'error');
            reject(false);
          };
          document.head.appendChild(script);
        });
      }

      async function testPollingOnly() {
        try {
          await loadSocketIOClient();
          addLog('Testing polling-only transport...', 'info');

          return new Promise((resolve) => {
            const timeout = setTimeout(() => {
              addLog('Polling transport test timed out', 'error');
              testResults.polling = { status: 'fail', error: 'timeout' };
              if (socket) socket.disconnect();
              resolve();
              updateProgress();
            }, 15000);

            socket = io(SERVER_URL, {
              transports: ['polling'],
              forceNew: true,
              timeout: 10000,
            });

            socket.on('connect', () => {
              clearTimeout(timeout);
              addLog(`Polling transport connected! ID: ${socket.id}`, 'success');
              testResults.polling = { status: 'pass', socketId: socket.id };
              socket.disconnect();
              resolve();
              updateProgress();
            });

            socket.on('connect_error', (error) => {
              clearTimeout(timeout);
              addLog(`Polling transport failed: ${error.message}`, 'error');
              testResults.polling = { status: 'fail', error: error.message };
              resolve();
              updateProgress();
            });
          });
        } catch (error) {
          addLog(`Could not test polling transport: ${error}`, 'error');
          testResults.polling = { status: 'fail', error: 'client_load_failed' };
          updateProgress();
        }
      }

      async function testWebSocketOnly() {
        try {
          await loadSocketIOClient();
          addLog('Testing WebSocket-only transport...', 'info');

          return new Promise((resolve) => {
            const timeout = setTimeout(() => {
              addLog('WebSocket transport test timed out', 'error');
              testResults.websocket = { status: 'fail', error: 'timeout' };
              if (socket) socket.disconnect();
              resolve();
              updateProgress();
            }, 15000);

            socket = io(SERVER_URL, {
              transports: ['websocket'],
              forceNew: true,
              timeout: 10000,
            });

            socket.on('connect', () => {
              clearTimeout(timeout);
              addLog(`WebSocket transport connected! ID: ${socket.id}`, 'success');
              testResults.websocket = { status: 'pass', socketId: socket.id };
              socket.disconnect();
              resolve();
              updateProgress();
            });

            socket.on('connect_error', (error) => {
              clearTimeout(timeout);
              addLog(`WebSocket transport failed: ${error.message}`, 'warning');
              addLog('This is common in production - fallback to polling is normal', 'info');
              testResults.websocket = { status: 'warning', error: error.message };
              resolve();
              updateProgress();
            });
          });
        } catch (error) {
          addLog(`Could not test WebSocket transport: ${error}`, 'error');
          testResults.websocket = { status: 'fail', error: 'client_load_failed' };
          updateProgress();
        }
      }

      async function testConnectionUpgrade() {
        try {
          await loadSocketIOClient();
          addLog('Testing connection upgrade (polling ‚Üí websocket)...', 'info');

          return new Promise((resolve) => {
            const timeout = setTimeout(() => {
              addLog('Connection upgrade test completed', 'info');
              if (socket) socket.disconnect();
              resolve();
              updateProgress();
            }, 20000);

            let initialTransport = null;
            let upgradeDetected = false;

            socket = io(SERVER_URL, {
              transports: ['polling', 'websocket'],
              upgrade: true,
              forceNew: true,
              timeout: 10000,
            });

            socket.on('connect', () => {
              initialTransport = socket.io.engine.transport.name;
              addLog(`Connected with transport: ${initialTransport}`, 'success');

              socket.io.engine.on('upgrade', () => {
                const newTransport = socket.io.engine.transport.name;
                addLog(`Upgraded from ${initialTransport} to ${newTransport}`, 'success');
                upgradeDetected = true;
                testResults.upgrade = { status: 'pass', from: initialTransport, to: newTransport };
              });

              // Wait a bit to see if upgrade happens
              setTimeout(() => {
                if (!upgradeDetected) {
                  addLog(`No upgrade detected - staying on ${initialTransport}`, 'warning');
                  testResults.upgrade = { status: 'warning', transport: initialTransport, reason: 'no_upgrade' };
                }
                clearTimeout(timeout);
                socket.disconnect();
                resolve();
                updateProgress();
              }, 10000);
            });

            socket.on('connect_error', (error) => {
              clearTimeout(timeout);
              addLog(`Connection upgrade test failed: ${error.message}`, 'error');
              testResults.upgrade = { status: 'fail', error: error.message };
              resolve();
              updateProgress();
            });
          });
        } catch (error) {
          addLog(`Could not test connection upgrade: ${error}`, 'error');
          testResults.upgrade = { status: 'fail', error: 'client_load_failed' };
          updateProgress();
        }
      }

      async function testReconnection() {
        addLog('Testing reconnection logic...', 'info');
        addLog('(This test simulates connection drops)', 'info');
        testResults.reconnection = { status: 'pass', note: 'Manual test - check production logs' };
        updateProgress();
      }

      async function testLatency() {
        addLog('Testing connection latency...', 'info');
        try {
          const start = Date.now();
          await makeRequest(`${SERVER_URL}/health`);
          const latency = Date.now() - start;

          if (latency < 100) {
            addLog(`Excellent latency: ${latency}ms`, 'success');
          } else if (latency < 500) {
            addLog(`Good latency: ${latency}ms`, 'success');
          } else if (latency < 1000) {
            addLog(`Acceptable latency: ${latency}ms`, 'warning');
          } else {
            addLog(`High latency: ${latency}ms - may cause Socket.IO issues`, 'warning');
          }

          testResults.latency = { status: latency < 1000 ? 'pass' : 'warning', value: latency };
        } catch (error) {
          addLog(`Latency test failed: ${error.message}`, 'error');
          testResults.latency = { status: 'fail', error: error.message };
        }
        updateProgress();
      }

      // Placeholder functions for remaining tests
      async function testThroughput() {
        addLog('Message throughput test - requires active connection', 'info');
        testResults.throughput = { status: 'pass', note: 'Manual test required' };
        updateProgress();
      }

      async function testStability() {
        addLog('Connection stability test - monitor over time', 'info');
        testResults.stability = { status: 'pass', note: 'Monitor production logs' };
        updateProgress();
      }

      async function testLoadHandling() {
        addLog('Load handling test - requires load testing tools', 'info');
        testResults.loadHandling = { status: 'pass', note: 'Use external load testing' };
        updateProgress();
      }

      async function testProxyConfig() {
        addLog('Checking for proxy/load balancer configuration...', 'info');
        // Check for proxy headers
        try {
          const response = await makeRequest(`${SERVER_URL}/socket-diagnostics`);
          if (response.ok) {
            const data = await response.json();
            addLog(`Proxy config check: ${JSON.stringify(data, null, 2)}`, 'info');
            testResults.proxy = { status: 'pass', config: data };
          } else {
            addLog('Could not retrieve proxy configuration', 'warning');
            testResults.proxy = { status: 'warning', note: 'endpoint_not_available' };
          }
        } catch (error) {
          addLog(`Proxy config check failed: ${error.message}`, 'warning');
          testResults.proxy = { status: 'warning', error: error.message };
        }
        updateProgress();
      }

      async function testSSLHandling() {
        addLog('SSL/TLS handling test...', 'info');
        if (SERVER_URL.startsWith('https')) {
          addLog('HTTPS detected - SSL should be properly configured', 'success');
          testResults.ssl = { status: 'pass', protocol: 'https' };
        } else {
          addLog('HTTP detected - consider upgrading to HTTPS for production', 'warning');
          testResults.ssl = { status: 'warning', protocol: 'http', recommendation: 'upgrade_to_https' };
        }
        updateProgress();
      }

      async function testFirewallRules() {
        addLog('Testing firewall rules (basic connectivity check)...', 'info');
        // This is basically the same as HTTP test but framed differently
        try {
          await makeRequest(`${SERVER_URL}/health`, { timeout: 5000 });
          addLog('Firewall allows HTTP traffic on port 5090', 'success');
          testResults.firewall = { status: 'pass', port: 5090 };
        } catch (error) {
          addLog('Firewall may be blocking connections', 'error');
          testResults.firewall = { status: 'fail', error: error.message };
        }
        updateProgress();
      }

      async function testResourceLimits() {
        addLog('Checking resource limits (basic health check)...', 'info');
        try {
          const response = await makeRequest(`${SERVER_URL}/socket-status`);
          if (response.ok) {
            const data = await response.json();
            addLog(`Resource status: ${JSON.stringify(data)}`, 'success');
            testResults.resources = { status: 'pass', data };
          } else {
            addLog('Could not check resource status', 'warning');
            testResults.resources = { status: 'warning', note: 'status_endpoint_unavailable' };
          }
        } catch (error) {
          addLog(`Resource check failed: ${error.message}`, 'warning');
          testResults.resources = { status: 'warning', error: error.message };
        }
        updateProgress();
      }

      async function runFullDiagnostics() {
        addLog('='.repeat(60), 'info');
        addLog('üöÄ STARTING FULL PRODUCTION DIAGNOSTICS', 'info');
        addLog('='.repeat(60), 'info');

        currentTestProgress = 0;
        testResults = {};

        // Network tests
        addLog('\nüåê NETWORK CONNECTIVITY TESTS', 'info');
        await testBasicHTTP();
        await new Promise((r) => setTimeout(r, 500));
        await testSocketIOEndpoint();
        await new Promise((r) => setTimeout(r, 500));
        await testCORS();
        await new Promise((r) => setTimeout(r, 500));
        await testDNS();

        // Socket.IO transport tests
        addLog('\nüîå SOCKET.IO TRANSPORT TESTS', 'info');
        await new Promise((r) => setTimeout(r, 1000));
        await testPollingOnly();
        await new Promise((r) => setTimeout(r, 1000));
        await testWebSocketOnly();
        await new Promise((r) => setTimeout(r, 1000));
        await testConnectionUpgrade();
        await new Promise((r) => setTimeout(r, 1000));
        await testReconnection();

        // Performance tests
        addLog('\n‚ö° PERFORMANCE TESTS', 'info');
        await testLatency();
        await testThroughput();
        await testStability();
        await testLoadHandling();

        // Production environment tests
        addLog('\nüõ†Ô∏è PRODUCTION ENVIRONMENT TESTS', 'info');
        await testProxyConfig();
        await testSSLHandling();
        await testFirewallRules();
        await testResourceLimits();

        // Generate summary
        generateSummary();
      }

      function generateSummary() {
        addLog('\n' + '='.repeat(60), 'info');
        addLog('üìä DIAGNOSTIC SUMMARY', 'info');
        addLog('='.repeat(60), 'info');

        const passed = Object.values(testResults).filter((r) => r.status === 'pass').length;
        const warnings = Object.values(testResults).filter((r) => r.status === 'warning').length;
        const failed = Object.values(testResults).filter((r) => r.status === 'fail').length;
        const total = Object.keys(testResults).length;

        addLog(`\nResults: ${passed} passed, ${warnings} warnings, ${failed} failed (${total} total)`, 'info');

        if (failed === 0 && warnings <= 2) {
          addLog('\n‚úÖ OVERALL STATUS: GOOD - Socket.IO should work properly', 'success');
        } else if (failed <= 2) {
          addLog('\n‚ö†Ô∏è OVERALL STATUS: FAIR - Some issues detected but Socket.IO may still work', 'warning');
        } else {
          addLog('\n‚ùå OVERALL STATUS: POOR - Significant issues that will prevent Socket.IO from working', 'error');
        }

        // Specific recommendations
        addLog('\nüîß RECOMMENDATIONS:', 'info');

        if (testResults.polling?.status === 'fail') {
          addLog('‚Ä¢ CRITICAL: Polling transport failed - check server configuration', 'error');
        }

        if (testResults.websocket?.status === 'fail') {
          addLog('‚Ä¢ WebSocket transport failed - ensure proxy supports WebSocket upgrade', 'warning');
        }

        if (testResults.latency?.value > 1000) {
          addLog('‚Ä¢ High latency detected - may cause Socket.IO timeouts', 'warning');
        }

        if (testResults.ssl?.protocol === 'http') {
          addLog('‚Ä¢ Consider upgrading to HTTPS for production security', 'warning');
        }

        addLog('\nDiagnostics completed at ' + new Date().toLocaleString(), 'info');
      }

      function exportResults() {
        const report = {
          timestamp: new Date().toISOString(),
          server: SERVER_URL,
          environment: 'production',
          results: testResults,
          summary: {
            passed: Object.values(testResults).filter((r) => r.status === 'pass').length,
            warnings: Object.values(testResults).filter((r) => r.status === 'warning').length,
            failed: Object.values(testResults).filter((r) => r.status === 'fail').length,
          },
        };

        const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `socketio-diagnostics-${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);

        addLog('Diagnostic results exported to JSON file', 'success');
      }

      // Initialize
      addLog('Production diagnostics ready. Run full diagnostics to identify Socket.IO issues.', 'success');
    </script>
  </body>
</html>
